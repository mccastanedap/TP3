using gold.structures.automaton.*
using gold.visualization.automaton.*

procedure main(args:String[]) begin
    lexer = createTransducer()
	 testLexer(lexer)
end
  
        

procedure testLexer(M:ITransducer) begin
	var sc:java.util.Scanner(System.$in)
	
	while true do
		print "----------------------------"
		print "Enter an input string: "
		string:=""
		cond:=true
		while cond==true do
			a:= sc.nextLine().toString()
			if(a!="") then 
				string:=string+a+" "   //We add a space (which is also a separator to the end of the string)
			else
				cond=false
				print string
			end
			
		end
		result:=M.acceptsString(string)    
			tokenStream := M.getOutputString()
			print "The lexer did "+(result?"":"not ")+" accept the string."
			if result then print "Token Stream: "+ tokenStream end		
	end
end

 


var names
  
function createTransducer():ITransducer begin
	// Lexer: reads a string with lower casae letters, digits, parenthesis, and spaces.
	// outputs a string of {'(',')','+','*','v','n'}
Q:={"I","K","E","o","f","s","S","T","P","q","R","N"}∪{"error"} 

Σ:=('A'‥'Z')∪('a'‥'z')∪('0'‥'9')∪{'(',')',',','_',' ',';'}
Out:={"Cla", "Ext", "obj", "f", "s", "Pair", "Sup", "Th", "M", "R","N"}
q:="Init"
F:={"Init"}∪{"ERROR"}
 
	return GDeterministicTransducer(Q,Σ,Out,q,F,δ,g,h)
end

function δ(q,σ) begin
	if (q = "ERROR") then return "ERROR"
	elseif  σ ∈ {'(',')',' ', '\n' , ',' , '\t' , ';' } then return "Init"
			
	elseif (q="Init" or q="K" or q="E" or q="o" or q="f" or q="s" or q="S" or q="T" or
		q="P" or q="q" or q="R" or	q="N" ) and σ ∈ {'\n','\t',' '}
		then return "Init"
			

	
	else return "ERROR"
		
	end
	
end 



function g(q) begin
	return λ
end


function h(q,σ) begin
		var s: String
		s:= λ
		
		if q=="ERROR" then return "$"
		else if σ==':' then return String.valueOf(λ)
			
		elseif σ∈{' ',',','\n','\t',';',':', ' '} then
			if σ∉{' ','\n','\t'} then s:=String.valueOf(σ) end
			
			
			
			if q=="Init" then return s
				
			elseif q=="K" then return "Cla"
				
			elseif q=="E" then return "Ext"
				
			elseif q=="o" then return "obj"+s
				
			elseif q=="f" then return "f"+s
				
			elseif q=="s" then return "s"+s
				
			elseif q=="S" then return "Sup"+s
				
			elseif q=="T" then return "Th"+s
				
			elseif q=="P" then return "Pair"+s
				
			elseif q=="q" then return "q"+s	
				
			elseif q=="N" then return "new"+s	
				
			elseif q=="R" then return "Return"
				
			elseif q=="N" then return "new"+s		
				
			else return "v"+s
				
			end
			
		else return λ
			
		end
end
end

