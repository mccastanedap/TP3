using gold.structures.automaton.*
using gold.visualization.automaton.*

procedure main(args:String[]) begin
    lexer = createTransducer()
	 testLexer(lexer)
end
  
        

procedure testLexer(M:ITransducer) begin
	var sc:java.util.Scanner(System.$in)
	
	while true do
		print "----------------------------"
		print "Enter an input string: "
		string:=""
		cond:=true
		while cond==true do
			a:= sc.nextLine().toString()
			if(a!="") then 
				string:=string+a+" "   //We add a space (which is also a separator to the end of the string)
			else
				cond=false
				print string
			end
			
		end
		result:=M.acceptsString(string)    
			tokenStream := M.getOutputString()
			print "The lexer did "+(result?"":"not ")+" accept the string."
			if result then print "Token Stream: "+ tokenStream end		
	end
end

 


var names
  
function createTransducer():ITransducer begin
	// Lexer: reads a string with lower casae letters, digits, parenthesis, and spaces.
	// outputs a string of {'(',')','+','*','v','n'}
Q:={"I","K","E","o","f","s","S","T","P","q","R","N"}∪{"ERROR", "Init"} 

Σ:=('A'‥'Z')∪('a'‥'z')∪('0'‥'9')∪{'(',')',',','_',' ',';'}
Out:={'C','l','a', 'E','x','t', 'o','b','j', 'f', 's', 'P','a','i','r', 'S','u','p', 'T','h', 'M', 'R','N'}
q:="Init"
F:={"Init"}∪{"ERROR"}
 
	return GDeterministicTransducer(Q,Σ,Out,q,F,δ,g,h)
end

function δ(q,σ) begin
	if (q = "ERROR") then return "ERROR"
	elseif  σ ∈ {'(',')',' ', '\n' , ',' , '\t' , ';' } then return "Init"
			
	elseif (q="Init" or q="K" or q="E" or q="o" or q="f" or q="s" or q="S" or q="T" or
		q="P" or q="q" or q="R" or	q="N" ) and σ ∈ {'\n','\t',' '}
		then return "Init"
			

	
	else return "ERROR"
		
	end
	
end 



function g(q) begin
	return λ
end


function h(q,σ) begin
		var s: String
		s:= λ
		
		if q=="ERROR" then return "$"
		else if σ==':' then return String.valueOf(λ)
			
		elseif σ∈{' ',',','\n','\t',';',':', ' '} then
			if σ∉{' ','\n','\t'} then s:=String.valueOf(σ) end
			
			
			
			if q=="Init" then return s
				
			elseif q=="K" then return 'C'+'l'+'a'
				
			elseif q=="E" then return 'E'+'x'+'t'
				
			elseif q=="o" then return 'o'+'b'+'j'+s
				
			elseif q=="f" then return 'f'+s
				
			elseif q=="s" then return 's'+s
				
			elseif q=="S" then return 'S'+'u'+'p'+s
				
			elseif q=="T" then return 'T'+'h'+s
				
			elseif q=="P" then return 'P'+'a'+'i'+'r'+s
				
			elseif q=="q" then return 'q'+s	
				
			elseif q=="N" then return 'n'+'e'+'w'+s	
				
			elseif q=="R" then return 'R'+'e'+'t'+'u'+'r'+'n'
				
			elseif q=="N" then return 'n'+'e'+'w'+s		
				
			else return "v"+s
				
			end
			
		else return λ
			
		end
end
end

